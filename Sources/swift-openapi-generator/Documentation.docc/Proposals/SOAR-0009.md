# SOAR-0009: Type-safe streaming multipart support

Provide a type-safe, yet still streaming, way to produce and consume multipart bodies.

## Overview

- Proposal: SOAR-0009
- Author(s): [Honza Dvorsky](https://github.com/czechboy0)
- Status: **Awaiting Review**
- Issue: [apple/swift-openapi-generator#36](https://github.com/apple/swift-openapi-generator/issues/36)
- Implementation:
    - [apple/swift-openapi-runtime#69](https://github.com/apple/swift-openapi-runtime/pull/69)
    - [apple/swift-openapi-generator#366](https://github.com/apple/swift-openapi-generator/pull/366)
- Feature flag: `multipart`
- Affected components:
    - generator
    - runtime
- Links:
    - [OpenAPI 3.0.3 specification][openapi303]
    - [OpenAPI 3.1.0 specification][openapi310]
    - [Swagger.io documentation on multipart support in OpenAPI 3.x][swaggerio-multipart]
    - [RFC 7578: Returning Values from Forms: multipart/form-data][rfc7578]
    - [RFC 2046: Multipurpose Internet Mail Extensions (MIME) Part Two: Media Types][rfc2046]

### Introduction

Add support for multipart requests and responses by generating a type-safe representation of each part.

### Motivation

Since its first version, Swift OpenAPI Generator has supported OpenAPI operations that represent the most common HTTP request/response pairs.

For example, posting JSON data to a server, which can look like this:

```
> POST /cat-photo-metadata HTTP/1.1
> content-type: application/json
> x-sender-id: zoom123
>
> {"objectCatName":"Waffles","photographerId":24}
---
< HTTP/1.1 204 No Content
```

Or uploading a raw file, such as a photo, to a server:

```
> POST /cat-photo HTTP/1.1
> content-type: image/jpeg
>
> ...
---
< HTTP/1.1 204 No Content
```

In both of these examples, the HTTP message (a request or a response) has a single content type that describes the format of the whole body payload.

However, there are use cases where the client wants to send multiple different payloads, each of a different content type, in a single HTTP message. That's what the [multipart][rfc7578] content type is for, and this proposal describes how Swift OpenAPI Generator can add support for it, providing both type-safety while retaining a fully streaming API.

> Note: In this proposal, we mostly discuss an example of making a multipart request, but all the proposed features apply to multipart responses as well.

With multipart support, uploading both a JSON object and a raw file to the server in one request could look something like:

```
> POST /photos HTTP/1.1
> content-type: multipart/form-data; boundary=___MY_BOUNDARY_1234__
>
> --___MY_BOUNDARY_1234__
> content-disposition: form-data; name="metadata"
> content-type: application/json
> x-sender-id: zoom123
>
> {"objectCatName":"Waffles","photographerId":24}
> --___MY_BOUNDARY_1234__
> content-disposition: form-data; name="contents"
> content-type: image/jpeg
>
> ...
> --___MY_BOUNDARY_1234__--
---
< HTTP/1.1 204 No Content
```

While we'll discuss the structure of a multipart message in detail below, the TL;DR is:
- This is still a regular HTTP message, just with a different content type and body.
- The body uses the boundary string to separate individual _parts_.
- Each part has its own header fields and a body.

Extra requirements to keep in mind:
- A multipart message must have at least one part.
- But, a part can have no headers or an empty body.

### Proposed solution

As an example, let's consider a service that allows uploading cat photos together with additional JSON metadata in a single request, as seen in the previous section.

#### Describing a multipart request in OpenAPI

Let's define a `POST` request on the `/photos` path that accepts a `multipart/form-data` body containing 2 parts, one JSON part with the name "metadata", and another called "contents" that contains the raw JPEG bytes of the cat photo.

> Note: Parts do not have a predefined order, they can arrive in any order the sender chooses. So let's think of a multipart body as a _stream_ of parts.

In OpenAPI, the operation could look like this (irrelevant parts were omitted, see the full OpenAPI document in [Appendix A][TODO]):

```yaml
paths:
  /photos:
    post:
      requestBody:
        required: true
        content:
          multipart/form-data:
            schema:
              type: object
              properties:
                metadata:
                  $ref: '#/components/schemas/PhotoMetadata'
                contents:
                  type: string
                  contentEncoding: binary
              required:
                - metadata
                - contents
            encoding:
              metadata:
                headers:
                  x-sender-id:
                    schema:
                      type: string
              contents:
                contentType: image/jpeg
```

In OpenAPI, the schema for the multipart message is defined using JSON Schema, even though the top level schema is never actually serialized as JSON - it only serves as a way to define the individual parts.

The top level schema is always an object (or an object-ish type, such as allOf or anyOf of objects), and each property describes one part. Top level properties that describe an array schema are interpreted as a way to say that there might be more than one part of the provided name (matching the property name). The `required` property of the schema is used just like in regular JSON Schema – to communicate which properties (in this case, parts) are required and which are optional.

Finally, a sibling field of the `schema` is called `encoding` and mirrors the `schema` structure. For each part, you override the content type and add custom header fields for each part.

#### Generating a multipart request in Swift

As with other Swift OpenAPI Generator features, the goal of generating code for multipart is to maximize type-safety for adopters without compromising their ability to stream HTTP bodies.

With that in mind, multiple different strategies were considered for how to best represent a multipart body in Swift – for details, see the "Future directions" and "Alternatives considered" sections of this proposal.

To that end, we propose to represent a multipart body as an _async sequence of type-safe parts_ (called `MultipartBody` in this proposal and defined in the runtime library). This is motivated by the fact that multipart bodies can be gigabytes in size and contain hundreds of parts, so any Swift representation that forces buffering immediately prevents advanced use cases. 

> Note: That said, a proposal in the future might introduce an opt-in buffered variant of each type-safe body that builds on the foundation of the async sequence. If this is something you'd like to use, please open an issue on GitHub and start a thread on the Swift Forums, describing your use case.

Getting back to the cat photo service and our multipart request, the body definition would look something like (omitted irrelevant parts of code for brevity):

```swift
/// - Remark: Generated from `#/paths/photos/POST/requestBody/content`.
/* nested in Operations.uploadPhoto.Input */ {
    enum Body {
        enum multipartFormPayload {
            struct metadataPayload {
                struct Headers: Sendable, Hashable {
                    var x_dash_sender_dash_id: Swift.String?
                }
                var headers: Headers
                struct metadataPayloadBodyPayload: Codable {
                    var objectCatName: Swift.String
                    var photographerId: Swift.Int?
                }
                var body: metadataPayloadBodyPayload
            }
            case metadata(MultipartPart<metadataPayload>)
            struct contentsPayload {
                var body: OpenAPIRuntime.HTTPBody
            }
            case contents(MultipartPart<contentsPayload>)
            case undocumented(MultipartRawPart)
        }
        /// - Remark: Generated from `#/paths/photos/POST/requestBody/content/multipart\/form-data`.
        case multipartForm(OpenAPIRuntime.MultipartBody<multipartFormPayload>)
    }
}
```

The generated type `multipartFormPayload` is an enum with associated value, where each case is one of the parts documented in the OpenAPI document. By default, undocumented parts are also collected, and this behavior is controlled by the `additionalProperties` schema field - more on that in the "Detailed design" section below.

#### Producing a multipart body sequence

As a client sending this multipart request (or a server sending a multipart response), you are expected to provide a value of type `OpenAPIRuntime.MultipartBody<Part>`, where `Part` is your concrete generated enum:

```swift
let multipartBody: OpenAPIRuntime.MultipartBody<Operations.uploadPhoto.Input.Body.multipartFormPayload> = ...
let response = try await client.uploadPhoto(body: multipartBody)
// ...
```

Similarly to `OpenAPIRuntime.HTTPBody`, the `OpenAPIRuntime.MultipartBody` async sequence has several convenience initializers, making it easy to construct both from buffered and streaming sources.

For a buffered example, just provide an array of the part values, such as:

```swift
let multipartBody: OpenAPIRuntime.MultipartBody<Operations.uploadPhoto.Input.Body.multipartFormPayload> = [
    .metadata(.init(
        payload: .init(
            headers: .init(x_dash_sender_dash_id: "zoom123"),
            body: .init(objectCatName: "Waffles", photographerId: 24)
        )
    )),
    .contents(.init(
        payload: .init(
            body: .init(try Data(contentsOf: URL(fileURLWithPath: "/tmp/waffles-summer-2023.jpg")))
        ),
        filename: "cat.jpg"
    ))
]
let response = try await client.uploadPhoto(body: multipartBody)
// ...
```

However, you can also stream the parts and their bodies:

```swift
let (stream, continuation) = AsyncStream.makeStream(of: Operations.uploadPhoto.Input.Body.multipartFormPayload.self)
// Pass `continuation` to another task to start producing parts by calling `continuation.yield(...)` and at the end, `continuation.finish()`.
let response = try await client.uploadPhoto(body: .init(stream))
// ...
```

#### Consuming a multipart body sequence

When consuming a multipart body sequence, for example as a client consuming a multipart response, or a server consuming a multipart request, you are provided with the multipart body async sequence and are responsible for iterating it to completion.

Additionally, for received parts that have their own streaming bodies, you _must_ consume those bodies before requesting the new part, as the underlying async sequence never does any buffering for you, so you can't "skip" any parts or chunks of bytes within a part implicitly.

That means that most often, consuming a multipart body looks something like:

```swift
let multipartBody: OpenAPIRuntime.MultipartBody<Operations.uploadPhoto.Input.Body.multipartFormPayload> = ...
for try await part in multipartBody {
    switch part {
    case .metadata(let metadataPart):
        let metadata = metadataPart.payload
        print("x-sender-id: \(metadata.headers.x_dash_sender_dash_id ?? "<nil>")")
        print("Cat name: \(metadata.body.objectCatName)")
        print("Photographer ID: \(metadata.body.photographerId?.description ?? "<nil>")")
    case .contents(let contentsPart):
        // Ensure the incoming filepath doesn't try to escape to a parent directory, and so on, before using it.
        let fileName = contentsPart.filename ?? "\(UUID().uuidString).jpg" 
        guard let outputStream = OutputStream(toFileAtPath: "/tmp/received-cat-photos/\(fileName)", shouldAppend: false) else {
            // failed to open a stream
        }
        outputStream.open()
        defer {
            outputStream.close()
        }
        // Consume the body before moving to the next part.
        for try await chunk in contentsPart.body {
            chunk.withUnsafeBufferPointer { _ = outputStream.write($0.baseAddress!, maxLength: $0.count) }
        }
    case .undocumented(let rawPart):
        print("Received an undocumented part with header fields: \(rawPart.headerFields)")
        // Consume the body before moving to the next part.
        _ = try await ArraySlice<UInt8>(collecting: rawPart.body, upTo: 10 * 1024 * 1024)
    }
}
```

TODO: validation, an error is thrown if OpenAPI constraints are violated, no need to enforce that in user code

### Detailed design

TODO: Describe the implementation of the feature, a link to a prototype implementation is encouraged here.

TODO: This section should focus on what will change for the _contributors_ to Swift OpenAPI Generator.

TODO: ensuring only a single encoding + schema pair shows up for multipart, by comparing the contents. If there's a mismatch, emits a diagnostic and keeps the first pair found.

- TODO: Symmetry, client upload ~ server download (sending multipart), and client download ~ server upload (receiving multipart).
- TODO: Additional properties
    - unspecified ("undocumented" raw case)
    - true ("other") raw case
    - false (no extra case, validation sequence enforces the preconditionFailure is never hit)
    - true + type ("other" case, kind of like an array, but the name needs to be captured and surfaced)
- TODO: Boundary customization through configuration
- TODO: Access to the filename parameter in content-disposition
- TODO: Upload + optional request body = should be forbidden, fail in the generator as unsupported (skip + diagnostic), check with the scraper
- TODO: Encoding (custom headers)
- TODO: Encoding (explicitly specifying the content type, takes precedence over the default ones)
- TODO: Default content types based on schema type, from the OpenAPI specification.
- TODO: Arrays treated as multiple parts of the same name.
- TODO: Validation sequence - semantics enforced both when sending and receiving, both client and server.

### API stability

Discuss the API implications, making sure to considering all of:
- runtime public API
    - TODO: additive (non-breaking)
- runtime "Generated" SPI
    - TODO: breaking, a different type generated now, so behind a feature flag in 0.3.x

### Future directions

- TODO: A generated buffered representation with random access async properties (transparent buffering.)
- TODO: multipart/alternative, multipart/mixed, and other multipart subtypes.

### Alternatives considered

- TODO: Nothing: users compose and parse their own raw multipart requests/responses.
- TODO: Only surfacing the raw parts, no per-operation code generation.
- TODO: Not doing validation.
- TODO: Buffered representation (goes against 0.3.0, inverse layering.)

### Acknowledgements

A special thanks to [Si Beaumont](https://github.com/simonjbeaumont) for helping refine this proposal with thoughtful feedback.

[rfc7578]: https://www.rfc-editor.org/rfc/rfc7578
[rfc2046]: https://datatracker.ietf.org/doc/html/rfc2046
[rfc2046-section5.1]: https://datatracker.ietf.org/doc/html/rfc2046#section-5.1
[swaggerio-multipart]: https://swagger.io/docs/specification/describing-request-body/multipart-requests
[openapi303]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.3.md
[openapi310]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md
[openapi303-multipart]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.3.md#special-considerations-for-multipart-content
[openapi310-multipart]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#special-considerations-for-multipart-content

### Appendix A: Example OpenAPI document with multipart bodies

```yaml
openapi: '3.1.0'
info:
  title: Cat photo service
  version: 2.0.0
paths:
  /photos:
    post:
      operationId: uploadPhoto
      description: Uploads the provided photo with metadata to the server.
      requestBody:
        required: true
        content:
          multipart/form-data:
            schema:
              type: object
              description: The individual parts of the photo upload.
              properties:
                metadata:
                  $ref: '#/components/schemas/PhotoMetadata'
                  description: Extra information about the uploaded photo.
                contents:
                  type: string
                  contentEncoding: binary
                  description: The raw contents of the photo.
              required:
                - metadata
                - contents
            encoding:
              metadata:
                # No need to explicitly specify `contents: application/json` because 
                # it's inferred from the schema itself.
                headers:
                  x-sender-id:
                    # Note that this serves as an example of a part header. 
                    # But conventionally, you'd include this property in the metadata JSON instead.
                    description: The identifier of the device sending the photo.
                    schema:
                      type: string
              contents:
                contentType: image/jpeg
      responses:
        '204':
          description: Successfully uploaded the file.
components:
  schemas:
    PhotoMetadata:
      type: object
      description: Extra information about a photo.
      properties:
        objectCatName:
          type: string
          description: The name of the cat that's in the photo.
        photographerId:
          type: integer
          description: The identifier of the photographer.
      required:
        - objectCatName
```
