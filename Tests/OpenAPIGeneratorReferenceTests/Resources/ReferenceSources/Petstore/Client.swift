// Generated by swift-openapi-generator, do not modify.
@_spi(Generated) import OpenAPIRuntime
#if os(Linux)
@preconcurrency import struct Foundation.URL
@preconcurrency import struct Foundation.Data
@preconcurrency import struct Foundation.Date
#else
import struct Foundation.URL
import struct Foundation.Data
import struct Foundation.Date
#endif
import HTTPTypes
/// Service for managing pet metadata.
///
/// Because why not.
public struct Client: APIProtocol {
    /// The underlying HTTP client.
    private let client: UniversalClient
    /// Creates a new client.
    /// - Parameters:
    ///   - serverURL: The server URL that the client connects to. Any server
    ///   URLs defined in the OpenAPI document are available as static methods
    ///   on the ``Servers`` type.
    ///   - configuration: A set of configuration values for the client.
    ///   - transport: A transport that performs HTTP operations.
    ///   - middlewares: A list of middlewares to call before the transport.
    public init(
        serverURL: Foundation.URL,
        configuration: Configuration = .init(),
        transport: any ClientTransport,
        middlewares: [any ClientMiddleware] = []
    ) {
        self.client = .init(
            serverURL: serverURL,
            configuration: configuration,
            transport: transport,
            middlewares: middlewares
        )
    }
    private var converter: Converter {
        client.converter
    }
    /// List all pets
    ///
    /// You can fetch
    /// all the pets here
    ///
    /// - Remark: HTTP `GET /pets`.
    /// - Remark: Generated from `#/paths//pets/get(listPets)`.
    public func listPets(_ input: Operations.ListPets.Input) async throws -> Operations.ListPets.Output {
        try await client.send(
            input: input,
            forOperation: Operations.ListPets.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/pets",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "limit",
                    value: input.query.limit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "habitat",
                    value: input.query.habitat
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "feeds",
                    value: input.query.feeds
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "My-Request-UUID",
                    value: input.headers.myRequestUUID
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "since",
                    value: input.query.since
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.ListPets.Output.Ok.Headers = .init(
                        myResponseUUID: try converter.getRequiredHeaderFieldAsURI(
                            in: response.headerFields,
                            name: "My-Response-UUID",
                            as: Swift.String.self
                        ),
                        myTracingHeader: try converter.getOptionalHeaderFieldAsURI(
                            in: response.headerFields,
                            name: "My-Tracing-Header",
                            as: Components.Headers.TracingHeader.self
                        )
                    )
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.ListPets.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Pets.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.ListPets.Output.Default.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .`default`(
                        statusCode: response.status.code,
                        .init(body: body)
                    )
                }
            }
        )
    }
    /// Create a pet
    ///
    /// - Remark: HTTP `POST /pets`.
    /// - Remark: Generated from `#/paths//pets/post(createPet)`.
    public func createPet(_ input: Operations.CreatePet.Input) async throws -> Operations.CreatePet.Output {
        try await client.send(
            input: input,
            forOperation: Operations.CreatePet.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/pets",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsJSON(
                    in: &request.headerFields,
                    name: "X-Extra-Arguments",
                    value: input.headers.xExtraArguments
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let headers: Operations.CreatePet.Output.Created.Headers = .init(xExtraArguments: try converter.getOptionalHeaderFieldAsJSON(
                        in: response.headerFields,
                        name: "X-Extra-Arguments",
                        as: Components.Schemas.CodeError.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.CreatePet.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Pet.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(
                        headers: headers,
                        body: body
                    ))
                case 400 ... 499:
                    let headers: Components.Responses.ErrorBadRequest.Headers = .init(xReason: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "X-Reason",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.ErrorBadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses.ErrorBadRequest.Body.JsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .clientError(
                        statusCode: response.status.code,
                        .init(
                            headers: headers,
                            body: body
                        )
                    )
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create a pet using a url form
    ///
    /// - Remark: HTTP `POST /pets/create`.
    /// - Remark: Generated from `#/paths//pets/create/post(createPetWithForm)`.
    public func createPetWithForm(_ input: Operations.CreatePetWithForm.Input) async throws -> Operations.CreatePetWithForm.Output {
        try await client.send(
            input: input,
            forOperation: Operations.CreatePetWithForm.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/pets/create",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .urlEncodedForm(value):
                    body = try converter.setRequiredRequestBodyAsURLEncodedForm(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/x-www-form-urlencoded"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 204:
                    return .noContent(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `GET /pets/stats`.
    /// - Remark: Generated from `#/paths//pets/stats/get(getStats)`.
    public func getStats(_ input: Operations.GetStats.Input) async throws -> Operations.GetStats.Output {
        try await client.send(
            input: input,
            forOperation: Operations.GetStats.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/pets/stats",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.GetStats.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "text/plain",
                            "application/octet-stream"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.PetStats.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "text/plain":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .plainText(value)
                            }
                        )
                    case "application/octet-stream":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .binary(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `POST /pets/stats`.
    /// - Remark: Generated from `#/paths//pets/stats/post(postStats)`.
    public func postStats(_ input: Operations.PostStats.Input) async throws -> Operations.PostStats.Output {
        try await client.send(
            input: input,
            forOperation: Operations.PostStats.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/pets/stats",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                case let .plainText(value):
                    body = try converter.setRequiredRequestBodyAsBinary(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "text/plain"
                    )
                case let .binary(value):
                    body = try converter.setRequiredRequestBodyAsBinary(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/octet-stream"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 202:
                    return .accepted(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `POST /probe/`.
    /// - Remark: Generated from `#/paths//probe//post(probe)`.
    public func probe(_ input: Operations.Probe.Input) async throws -> Operations.Probe.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Probe.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/probe/",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 204:
                    return .noContent(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Update just a specific property of an existing pet. Nothing is updated if no request body is provided.
    ///
    /// - Remark: HTTP `PATCH /pets/{petId}`.
    /// - Remark: Generated from `#/paths//pets/{petId}/patch(updatePet)`.
    public func updatePet(_ input: Operations.UpdatePet.Input) async throws -> Operations.UpdatePet.Output {
        try await client.send(
            input: input,
            forOperation: Operations.UpdatePet.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/pets/{}",
                    parameters: [
                        input.path.petId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .patch
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case .none:
                    body = nil
                case let .json(value):
                    body = try converter.setOptionalRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 204:
                    return .noContent(.init())
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.UpdatePet.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.UpdatePet.Output.BadRequest.Body.JsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Upload an avatar
    ///
    /// - Remark: HTTP `PUT /pets/{petId}/avatar`.
    /// - Remark: Generated from `#/paths//pets/{petId}/avatar/put(uploadAvatarForPet)`.
    public func uploadAvatarForPet(_ input: Operations.UploadAvatarForPet.Input) async throws -> Operations.UploadAvatarForPet.Output {
        try await client.send(
            input: input,
            forOperation: Operations.UploadAvatarForPet.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/pets/{}/avatar",
                    parameters: [
                        input.path.petId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .put
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .binary(value):
                    body = try converter.setRequiredRequestBodyAsBinary(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/octet-stream"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.UploadAvatarForPet.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/octet-stream"
                        ]
                    )
                    switch chosenContentType {
                    case "application/octet-stream":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .binary(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 412:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.UploadAvatarForPet.Output.PreconditionFailed.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Swift.String.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .preconditionFailed(.init(body: body))
                case 500:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.UploadAvatarForPet.Output.InternalServerError.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "text/plain"
                        ]
                    )
                    switch chosenContentType {
                    case "text/plain":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .plainText(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .internalServerError(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `GET /pets/multipart-typed`.
    /// - Remark: Generated from `#/paths//pets/multipart-typed/get(multipartDownloadTyped)`.
    public func multipartDownloadTyped(_ input: Operations.MultipartDownloadTyped.Input) async throws -> Operations.MultipartDownloadTyped.Output {
        try await client.send(
            input: input,
            forOperation: Operations.MultipartDownloadTyped.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/pets/multipart-typed",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.MultipartDownloadTypedResponse.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "multipart/form-data"
                        ]
                    )
                    switch chosenContentType {
                    case "multipart/form-data":
                        body = try converter.getResponseBodyAsMultipart(
                            OpenAPIRuntime.MultipartBody<Components.Responses.MultipartDownloadTypedResponse.Body.MultipartFormPayload>.self,
                            from: responseBody,
                            transforming: { value in
                                .multipartForm(value)
                            },
                            boundary: contentType.requiredBoundary(),
                            allowsUnknownParts: true,
                            requiredExactlyOncePartNames: [
                                "log"
                            ],
                            requiredAtLeastOncePartNames: [],
                            atMostOncePartNames: [
                                "metadata"
                            ],
                            zeroOrMoreTimesPartNames: [
                                "keyword"
                            ],
                            decoding: { part in
                                let headerFields = part.headerFields
                                let (name, filename) = try converter.extractContentDispositionNameAndFilename(in: headerFields)
                                switch name {
                                case "log":
                                    let headers: Components.Responses.MultipartDownloadTypedResponse.Body.MultipartFormPayload.LogPayload.Headers = .init(xLogType: try converter.getOptionalHeaderFieldAsURI(
                                        in: headerFields,
                                        name: "x-log-type",
                                        as: Components.Responses.MultipartDownloadTypedResponse.Body.MultipartFormPayload.LogPayload.Headers.XLogTypePayload.self
                                    ))
                                    try converter.verifyContentTypeIfPresent(
                                        in: headerFields,
                                        matches: "text/plain"
                                    )
                                    let body = try converter.getResponseBodyAsBinary(
                                        OpenAPIRuntime.HTTPBody.self,
                                        from: part.body,
                                        transforming: {
                                            $0
                                        }
                                    )
                                    return .log(.init(
                                        payload: .init(
                                            headers: headers,
                                            body: body
                                        ),
                                        filename: filename
                                    ))
                                case "metadata":
                                    try converter.verifyContentTypeIfPresent(
                                        in: headerFields,
                                        matches: "application/json"
                                    )
                                    let body = try await converter.getResponseBodyAsJSON(
                                        Components.Responses.MultipartDownloadTypedResponse.Body.MultipartFormPayload.MetadataPayload.BodyPayload.self,
                                        from: part.body,
                                        transforming: {
                                            $0
                                        }
                                    )
                                    return .metadata(.init(
                                        payload: .init(body: body),
                                        filename: filename
                                    ))
                                case "keyword":
                                    try converter.verifyContentTypeIfPresent(
                                        in: headerFields,
                                        matches: "text/plain"
                                    )
                                    let body = try converter.getResponseBodyAsBinary(
                                        OpenAPIRuntime.HTTPBody.self,
                                        from: part.body,
                                        transforming: {
                                            $0
                                        }
                                    )
                                    return .keyword(.init(
                                        payload: .init(body: body),
                                        filename: filename
                                    ))
                                default:
                                    return .undocumented(part)
                                }
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `POST /pets/multipart-typed`.
    /// - Remark: Generated from `#/paths//pets/multipart-typed/post(multipartUploadTyped)`.
    public func multipartUploadTyped(_ input: Operations.MultipartUploadTyped.Input) async throws -> Operations.MultipartUploadTyped.Output {
        try await client.send(
            input: input,
            forOperation: Operations.MultipartUploadTyped.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/pets/multipart-typed",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .multipartForm(value):
                    body = try converter.setRequiredRequestBodyAsMultipart(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "multipart/form-data",
                        allowsUnknownParts: true,
                        requiredExactlyOncePartNames: [
                            "log"
                        ],
                        requiredAtLeastOncePartNames: [],
                        atMostOncePartNames: [
                            "metadata"
                        ],
                        zeroOrMoreTimesPartNames: [
                            "keyword"
                        ],
                        encoding: { part in
                            switch part {
                            case let .log(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                try converter.setHeaderFieldAsURI(
                                    in: &headerFields,
                                    name: "x-log-type",
                                    value: value.headers.xLogType
                                )
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "log",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .metadata(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsJSON(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "application/json; charset=utf-8"
                                )
                                return .init(
                                    name: "metadata",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .keyword(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "keyword",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .undocumented(value):
                                return value
                            }
                        }
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 202:
                    return .accepted(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
}
