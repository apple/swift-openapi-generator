// Generated by swift-openapi-generator, do not modify.
@_spi(Generated) import OpenAPIRuntime
#if os(Linux)
@preconcurrency import struct Foundation.URL
@preconcurrency import struct Foundation.Data
@preconcurrency import struct Foundation.Date
#else
import struct Foundation.URL
import struct Foundation.Data
import struct Foundation.Date
#endif
import HTTPTypes
extension APIProtocol {
    /// Registers each operation handler with the provided transport.
    /// - Parameters:
    ///   - transport: A transport to which to register the operation handlers.
    ///   - serverURL: A URL used to determine the path prefix for registered
    ///   request handlers.
    ///   - configuration: A set of configuration values for the server.
    ///   - middlewares: A list of middlewares to call before the handler.
    public func registerHandlers(
        on transport: any ServerTransport,
        serverURL: Foundation.URL = .defaultOpenAPIServerURL,
        configuration: Configuration = .init(),
        middlewares: [any ServerMiddleware] = []
    ) throws {
        let server = UniversalServer(
            serverURL: serverURL,
            handler: self,
            configuration: configuration,
            middlewares: middlewares
        )
        try transport.register(
            {
                try await server.listPets(
                    request: $0,
                    body: $1,
                    metadata: $2
                )
            },
            method: .get,
            path: server.apiPathComponentsWithServerPrefix("/pets")
        )
        try transport.register(
            {
                try await server.createPet(
                    request: $0,
                    body: $1,
                    metadata: $2
                )
            },
            method: .post,
            path: server.apiPathComponentsWithServerPrefix("/pets")
        )
        try transport.register(
            {
                try await server.createPetWithForm(
                    request: $0,
                    body: $1,
                    metadata: $2
                )
            },
            method: .post,
            path: server.apiPathComponentsWithServerPrefix("/pets/create")
        )
        try transport.register(
            {
                try await server.getStats(
                    request: $0,
                    body: $1,
                    metadata: $2
                )
            },
            method: .get,
            path: server.apiPathComponentsWithServerPrefix("/pets/stats")
        )
        try transport.register(
            {
                try await server.postStats(
                    request: $0,
                    body: $1,
                    metadata: $2
                )
            },
            method: .post,
            path: server.apiPathComponentsWithServerPrefix("/pets/stats")
        )
        try transport.register(
            {
                try await server.probe(
                    request: $0,
                    body: $1,
                    metadata: $2
                )
            },
            method: .post,
            path: server.apiPathComponentsWithServerPrefix("/probe/")
        )
        try transport.register(
            {
                try await server.updatePet(
                    request: $0,
                    body: $1,
                    metadata: $2
                )
            },
            method: .patch,
            path: server.apiPathComponentsWithServerPrefix("/pets/{petId}")
        )
        try transport.register(
            {
                try await server.uploadAvatarForPet(
                    request: $0,
                    body: $1,
                    metadata: $2
                )
            },
            method: .put,
            path: server.apiPathComponentsWithServerPrefix("/pets/{petId}/avatar")
        )
        try transport.register(
            {
                try await server.multipartDownloadTyped(
                    request: $0,
                    body: $1,
                    metadata: $2
                )
            },
            method: .get,
            path: server.apiPathComponentsWithServerPrefix("/pets/multipart-typed")
        )
        try transport.register(
            {
                try await server.multipartUploadTyped(
                    request: $0,
                    body: $1,
                    metadata: $2
                )
            },
            method: .post,
            path: server.apiPathComponentsWithServerPrefix("/pets/multipart-typed")
        )
    }
}

fileprivate extension UniversalServer where APIHandler: APIProtocol {
    /// List all pets
    ///
    /// You can fetch
    /// all the pets here
    ///
    /// - Remark: HTTP `GET /pets`.
    /// - Remark: Generated from `#/paths//pets/get(listPets)`.
    func listPets(
        request: HTTPTypes.HTTPRequest,
        body: OpenAPIRuntime.HTTPBody?,
        metadata: OpenAPIRuntime.ServerRequestMetadata
    ) async throws -> (HTTPTypes.HTTPResponse, OpenAPIRuntime.HTTPBody?) {
        try await handle(
            request: request,
            requestBody: body,
            metadata: metadata,
            forOperation: Operations.ListPets.id,
            using: {
                APIHandler.listPets($0)
            },
            deserializer: { request, requestBody, metadata in
                let query: Operations.ListPets.Input.Query = .init(
                    limit: try converter.getOptionalQueryItemAsURI(
                        in: request.soar_query,
                        style: .form,
                        explode: true,
                        name: "limit",
                        as: Swift.Int32.self
                    ),
                    habitat: try converter.getOptionalQueryItemAsURI(
                        in: request.soar_query,
                        style: .form,
                        explode: true,
                        name: "habitat",
                        as: Operations.ListPets.Input.Query.HabitatPayload.self
                    ),
                    feeds: try converter.getOptionalQueryItemAsURI(
                        in: request.soar_query,
                        style: .form,
                        explode: true,
                        name: "feeds",
                        as: Operations.ListPets.Input.Query.FeedsPayload.self
                    ),
                    since: try converter.getOptionalQueryItemAsURI(
                        in: request.soar_query,
                        style: .form,
                        explode: true,
                        name: "since",
                        as: Components.Parameters.Query_bornSince.self
                    )
                )
                let headers: Operations.ListPets.Input.Headers = .init(
                    myRequestUUID: try converter.getOptionalHeaderFieldAsURI(
                        in: request.headerFields,
                        name: "My-Request-UUID",
                        as: Swift.String.self
                    ),
                    accept: try converter.extractAcceptHeaderIfPresent(in: request.headerFields)
                )
                return Operations.ListPets.Input(
                    query: query,
                    headers: headers
                )
            },
            serializer: { output, request in
                switch output {
                case let .ok(value):
                    suppressUnusedWarning(value)
                    var response = HTTPTypes.HTTPResponse(soar_statusCode: 200)
                    suppressMutabilityWarning(&response)
                    try converter.setHeaderFieldAsURI(
                        in: &response.headerFields,
                        name: "My-Response-UUID",
                        value: value.headers.myResponseUUID
                    )
                    try converter.setHeaderFieldAsURI(
                        in: &response.headerFields,
                        name: "My-Tracing-Header",
                        value: value.headers.myTracingHeader
                    )
                    let body: OpenAPIRuntime.HTTPBody
                    switch value.body {
                    case let .json(value):
                        try converter.validateAcceptIfPresent(
                            "application/json",
                            in: request.headerFields
                        )
                        body = try converter.setResponseBodyAsJSON(
                            value,
                            headerFields: &response.headerFields,
                            contentType: "application/json; charset=utf-8"
                        )
                    }
                    return (response, body)
                case let .`default`(statusCode, value):
                    suppressUnusedWarning(value)
                    var response = HTTPTypes.HTTPResponse(soar_statusCode: statusCode)
                    suppressMutabilityWarning(&response)
                    let body: OpenAPIRuntime.HTTPBody
                    switch value.body {
                    case let .json(value):
                        try converter.validateAcceptIfPresent(
                            "application/json",
                            in: request.headerFields
                        )
                        body = try converter.setResponseBodyAsJSON(
                            value,
                            headerFields: &response.headerFields,
                            contentType: "application/json; charset=utf-8"
                        )
                    }
                    return (response, body)
                }
            }
        )
    }
    /// Create a pet
    ///
    /// - Remark: HTTP `POST /pets`.
    /// - Remark: Generated from `#/paths//pets/post(createPet)`.
    func createPet(
        request: HTTPTypes.HTTPRequest,
        body: OpenAPIRuntime.HTTPBody?,
        metadata: OpenAPIRuntime.ServerRequestMetadata
    ) async throws -> (HTTPTypes.HTTPResponse, OpenAPIRuntime.HTTPBody?) {
        try await handle(
            request: request,
            requestBody: body,
            metadata: metadata,
            forOperation: Operations.CreatePet.id,
            using: {
                APIHandler.createPet($0)
            },
            deserializer: { request, requestBody, metadata in
                let headers: Operations.CreatePet.Input.Headers = .init(
                    xExtraArguments: try converter.getOptionalHeaderFieldAsJSON(
                        in: request.headerFields,
                        name: "X-Extra-Arguments",
                        as: Components.Schemas.CodeError.self
                    ),
                    accept: try converter.extractAcceptHeaderIfPresent(in: request.headerFields)
                )
                let contentType = converter.extractContentTypeIfPresent(in: request.headerFields)
                let body: Operations.CreatePet.Input.Body
                let chosenContentType = try converter.bestContentType(
                    received: contentType,
                    options: [
                        "application/json"
                    ]
                )
                switch chosenContentType {
                case "application/json":
                    body = try await converter.getRequiredRequestBodyAsJSON(
                        Components.Schemas.CreatePetRequest.self,
                        from: requestBody,
                        transforming: { value in
                            .json(value)
                        }
                    )
                default:
                    preconditionFailure("bestContentType chose an invalid content type.")
                }
                return Operations.CreatePet.Input(
                    headers: headers,
                    body: body
                )
            },
            serializer: { output, request in
                switch output {
                case let .created(value):
                    suppressUnusedWarning(value)
                    var response = HTTPTypes.HTTPResponse(soar_statusCode: 201)
                    suppressMutabilityWarning(&response)
                    try converter.setHeaderFieldAsJSON(
                        in: &response.headerFields,
                        name: "X-Extra-Arguments",
                        value: value.headers.xExtraArguments
                    )
                    let body: OpenAPIRuntime.HTTPBody
                    switch value.body {
                    case let .json(value):
                        try converter.validateAcceptIfPresent(
                            "application/json",
                            in: request.headerFields
                        )
                        body = try converter.setResponseBodyAsJSON(
                            value,
                            headerFields: &response.headerFields,
                            contentType: "application/json; charset=utf-8"
                        )
                    }
                    return (response, body)
                case let .clientError(statusCode, value):
                    suppressUnusedWarning(value)
                    var response = HTTPTypes.HTTPResponse(soar_statusCode: statusCode)
                    suppressMutabilityWarning(&response)
                    try converter.setHeaderFieldAsURI(
                        in: &response.headerFields,
                        name: "X-Reason",
                        value: value.headers.xReason
                    )
                    let body: OpenAPIRuntime.HTTPBody
                    switch value.body {
                    case let .json(value):
                        try converter.validateAcceptIfPresent(
                            "application/json",
                            in: request.headerFields
                        )
                        body = try converter.setResponseBodyAsJSON(
                            value,
                            headerFields: &response.headerFields,
                            contentType: "application/json; charset=utf-8"
                        )
                    }
                    return (response, body)
                case let .undocumented(statusCode, _):
                    return (.init(soar_statusCode: statusCode), nil)
                }
            }
        )
    }
    /// Create a pet using a url form
    ///
    /// - Remark: HTTP `POST /pets/create`.
    /// - Remark: Generated from `#/paths//pets/create/post(createPetWithForm)`.
    func createPetWithForm(
        request: HTTPTypes.HTTPRequest,
        body: OpenAPIRuntime.HTTPBody?,
        metadata: OpenAPIRuntime.ServerRequestMetadata
    ) async throws -> (HTTPTypes.HTTPResponse, OpenAPIRuntime.HTTPBody?) {
        try await handle(
            request: request,
            requestBody: body,
            metadata: metadata,
            forOperation: Operations.CreatePetWithForm.id,
            using: {
                APIHandler.createPetWithForm($0)
            },
            deserializer: { request, requestBody, metadata in
                let contentType = converter.extractContentTypeIfPresent(in: request.headerFields)
                let body: Operations.CreatePetWithForm.Input.Body
                let chosenContentType = try converter.bestContentType(
                    received: contentType,
                    options: [
                        "application/x-www-form-urlencoded"
                    ]
                )
                switch chosenContentType {
                case "application/x-www-form-urlencoded":
                    body = try await converter.getRequiredRequestBodyAsURLEncodedForm(
                        Components.Schemas.CreatePetRequest.self,
                        from: requestBody,
                        transforming: { value in
                            .urlEncodedForm(value)
                        }
                    )
                default:
                    preconditionFailure("bestContentType chose an invalid content type.")
                }
                return Operations.CreatePetWithForm.Input(body: body)
            },
            serializer: { output, request in
                switch output {
                case let .noContent(value):
                    suppressUnusedWarning(value)
                    var response = HTTPTypes.HTTPResponse(soar_statusCode: 204)
                    suppressMutabilityWarning(&response)
                    return (response, nil)
                case let .undocumented(statusCode, _):
                    return (.init(soar_statusCode: statusCode), nil)
                }
            }
        )
    }
    /// - Remark: HTTP `GET /pets/stats`.
    /// - Remark: Generated from `#/paths//pets/stats/get(getStats)`.
    func getStats(
        request: HTTPTypes.HTTPRequest,
        body: OpenAPIRuntime.HTTPBody?,
        metadata: OpenAPIRuntime.ServerRequestMetadata
    ) async throws -> (HTTPTypes.HTTPResponse, OpenAPIRuntime.HTTPBody?) {
        try await handle(
            request: request,
            requestBody: body,
            metadata: metadata,
            forOperation: Operations.GetStats.id,
            using: {
                APIHandler.getStats($0)
            },
            deserializer: { request, requestBody, metadata in
                let headers: Operations.GetStats.Input.Headers = .init(accept: try converter.extractAcceptHeaderIfPresent(in: request.headerFields))
                return Operations.GetStats.Input(headers: headers)
            },
            serializer: { output, request in
                switch output {
                case let .ok(value):
                    suppressUnusedWarning(value)
                    var response = HTTPTypes.HTTPResponse(soar_statusCode: 200)
                    suppressMutabilityWarning(&response)
                    let body: OpenAPIRuntime.HTTPBody
                    switch value.body {
                    case let .json(value):
                        try converter.validateAcceptIfPresent(
                            "application/json",
                            in: request.headerFields
                        )
                        body = try converter.setResponseBodyAsJSON(
                            value,
                            headerFields: &response.headerFields,
                            contentType: "application/json; charset=utf-8"
                        )
                    case let .plainText(value):
                        try converter.validateAcceptIfPresent(
                            "text/plain",
                            in: request.headerFields
                        )
                        body = try converter.setResponseBodyAsBinary(
                            value,
                            headerFields: &response.headerFields,
                            contentType: "text/plain"
                        )
                    case let .binary(value):
                        try converter.validateAcceptIfPresent(
                            "application/octet-stream",
                            in: request.headerFields
                        )
                        body = try converter.setResponseBodyAsBinary(
                            value,
                            headerFields: &response.headerFields,
                            contentType: "application/octet-stream"
                        )
                    }
                    return (response, body)
                case let .undocumented(statusCode, _):
                    return (.init(soar_statusCode: statusCode), nil)
                }
            }
        )
    }
    /// - Remark: HTTP `POST /pets/stats`.
    /// - Remark: Generated from `#/paths//pets/stats/post(postStats)`.
    func postStats(
        request: HTTPTypes.HTTPRequest,
        body: OpenAPIRuntime.HTTPBody?,
        metadata: OpenAPIRuntime.ServerRequestMetadata
    ) async throws -> (HTTPTypes.HTTPResponse, OpenAPIRuntime.HTTPBody?) {
        try await handle(
            request: request,
            requestBody: body,
            metadata: metadata,
            forOperation: Operations.PostStats.id,
            using: {
                APIHandler.postStats($0)
            },
            deserializer: { request, requestBody, metadata in
                let contentType = converter.extractContentTypeIfPresent(in: request.headerFields)
                let body: Operations.PostStats.Input.Body
                let chosenContentType = try converter.bestContentType(
                    received: contentType,
                    options: [
                        "application/json",
                        "text/plain",
                        "application/octet-stream"
                    ]
                )
                switch chosenContentType {
                case "application/json":
                    body = try await converter.getRequiredRequestBodyAsJSON(
                        Components.Schemas.PetStats.self,
                        from: requestBody,
                        transforming: { value in
                            .json(value)
                        }
                    )
                case "text/plain":
                    body = try converter.getRequiredRequestBodyAsBinary(
                        OpenAPIRuntime.HTTPBody.self,
                        from: requestBody,
                        transforming: { value in
                            .plainText(value)
                        }
                    )
                case "application/octet-stream":
                    body = try converter.getRequiredRequestBodyAsBinary(
                        OpenAPIRuntime.HTTPBody.self,
                        from: requestBody,
                        transforming: { value in
                            .binary(value)
                        }
                    )
                default:
                    preconditionFailure("bestContentType chose an invalid content type.")
                }
                return Operations.PostStats.Input(body: body)
            },
            serializer: { output, request in
                switch output {
                case let .accepted(value):
                    suppressUnusedWarning(value)
                    var response = HTTPTypes.HTTPResponse(soar_statusCode: 202)
                    suppressMutabilityWarning(&response)
                    return (response, nil)
                case let .undocumented(statusCode, _):
                    return (.init(soar_statusCode: statusCode), nil)
                }
            }
        )
    }
    /// - Remark: HTTP `POST /probe/`.
    /// - Remark: Generated from `#/paths//probe//post(probe)`.
    func probe(
        request: HTTPTypes.HTTPRequest,
        body: OpenAPIRuntime.HTTPBody?,
        metadata: OpenAPIRuntime.ServerRequestMetadata
    ) async throws -> (HTTPTypes.HTTPResponse, OpenAPIRuntime.HTTPBody?) {
        try await handle(
            request: request,
            requestBody: body,
            metadata: metadata,
            forOperation: Operations.Probe.id,
            using: {
                APIHandler.probe($0)
            },
            deserializer: { request, requestBody, metadata in
                return Operations.Probe.Input()
            },
            serializer: { output, request in
                switch output {
                case let .noContent(value):
                    suppressUnusedWarning(value)
                    var response = HTTPTypes.HTTPResponse(soar_statusCode: 204)
                    suppressMutabilityWarning(&response)
                    return (response, nil)
                case let .undocumented(statusCode, _):
                    return (.init(soar_statusCode: statusCode), nil)
                }
            }
        )
    }
    /// Update just a specific property of an existing pet. Nothing is updated if no request body is provided.
    ///
    /// - Remark: HTTP `PATCH /pets/{petId}`.
    /// - Remark: Generated from `#/paths//pets/{petId}/patch(updatePet)`.
    func updatePet(
        request: HTTPTypes.HTTPRequest,
        body: OpenAPIRuntime.HTTPBody?,
        metadata: OpenAPIRuntime.ServerRequestMetadata
    ) async throws -> (HTTPTypes.HTTPResponse, OpenAPIRuntime.HTTPBody?) {
        try await handle(
            request: request,
            requestBody: body,
            metadata: metadata,
            forOperation: Operations.UpdatePet.id,
            using: {
                APIHandler.updatePet($0)
            },
            deserializer: { request, requestBody, metadata in
                let path: Operations.UpdatePet.Input.Path = .init(petId: try converter.getPathParameterAsURI(
                    in: metadata.pathParameters,
                    name: "petId",
                    as: Swift.Int64.self
                ))
                let headers: Operations.UpdatePet.Input.Headers = .init(accept: try converter.extractAcceptHeaderIfPresent(in: request.headerFields))
                let contentType = converter.extractContentTypeIfPresent(in: request.headerFields)
                let body: Components.RequestBodies.UpdatePetRequest?
                let chosenContentType = try converter.bestContentType(
                    received: contentType,
                    options: [
                        "application/json"
                    ]
                )
                switch chosenContentType {
                case "application/json":
                    body = try await converter.getOptionalRequestBodyAsJSON(
                        Components.RequestBodies.UpdatePetRequest.JsonPayload.self,
                        from: requestBody,
                        transforming: { value in
                            .json(value)
                        }
                    )
                default:
                    preconditionFailure("bestContentType chose an invalid content type.")
                }
                return Operations.UpdatePet.Input(
                    path: path,
                    headers: headers,
                    body: body
                )
            },
            serializer: { output, request in
                switch output {
                case let .noContent(value):
                    suppressUnusedWarning(value)
                    var response = HTTPTypes.HTTPResponse(soar_statusCode: 204)
                    suppressMutabilityWarning(&response)
                    return (response, nil)
                case let .badRequest(value):
                    suppressUnusedWarning(value)
                    var response = HTTPTypes.HTTPResponse(soar_statusCode: 400)
                    suppressMutabilityWarning(&response)
                    let body: OpenAPIRuntime.HTTPBody
                    switch value.body {
                    case let .json(value):
                        try converter.validateAcceptIfPresent(
                            "application/json",
                            in: request.headerFields
                        )
                        body = try converter.setResponseBodyAsJSON(
                            value,
                            headerFields: &response.headerFields,
                            contentType: "application/json; charset=utf-8"
                        )
                    }
                    return (response, body)
                case let .undocumented(statusCode, _):
                    return (.init(soar_statusCode: statusCode), nil)
                }
            }
        )
    }
    /// Upload an avatar
    ///
    /// - Remark: HTTP `PUT /pets/{petId}/avatar`.
    /// - Remark: Generated from `#/paths//pets/{petId}/avatar/put(uploadAvatarForPet)`.
    func uploadAvatarForPet(
        request: HTTPTypes.HTTPRequest,
        body: OpenAPIRuntime.HTTPBody?,
        metadata: OpenAPIRuntime.ServerRequestMetadata
    ) async throws -> (HTTPTypes.HTTPResponse, OpenAPIRuntime.HTTPBody?) {
        try await handle(
            request: request,
            requestBody: body,
            metadata: metadata,
            forOperation: Operations.UploadAvatarForPet.id,
            using: {
                APIHandler.uploadAvatarForPet($0)
            },
            deserializer: { request, requestBody, metadata in
                let path: Operations.UploadAvatarForPet.Input.Path = .init(petId: try converter.getPathParameterAsURI(
                    in: metadata.pathParameters,
                    name: "petId",
                    as: Components.Parameters.Path_petId.self
                ))
                let headers: Operations.UploadAvatarForPet.Input.Headers = .init(accept: try converter.extractAcceptHeaderIfPresent(in: request.headerFields))
                let contentType = converter.extractContentTypeIfPresent(in: request.headerFields)
                let body: Operations.UploadAvatarForPet.Input.Body
                let chosenContentType = try converter.bestContentType(
                    received: contentType,
                    options: [
                        "application/octet-stream"
                    ]
                )
                switch chosenContentType {
                case "application/octet-stream":
                    body = try converter.getRequiredRequestBodyAsBinary(
                        OpenAPIRuntime.HTTPBody.self,
                        from: requestBody,
                        transforming: { value in
                            .binary(value)
                        }
                    )
                default:
                    preconditionFailure("bestContentType chose an invalid content type.")
                }
                return Operations.UploadAvatarForPet.Input(
                    path: path,
                    headers: headers,
                    body: body
                )
            },
            serializer: { output, request in
                switch output {
                case let .ok(value):
                    suppressUnusedWarning(value)
                    var response = HTTPTypes.HTTPResponse(soar_statusCode: 200)
                    suppressMutabilityWarning(&response)
                    let body: OpenAPIRuntime.HTTPBody
                    switch value.body {
                    case let .binary(value):
                        try converter.validateAcceptIfPresent(
                            "application/octet-stream",
                            in: request.headerFields
                        )
                        body = try converter.setResponseBodyAsBinary(
                            value,
                            headerFields: &response.headerFields,
                            contentType: "application/octet-stream"
                        )
                    }
                    return (response, body)
                case let .preconditionFailed(value):
                    suppressUnusedWarning(value)
                    var response = HTTPTypes.HTTPResponse(soar_statusCode: 412)
                    suppressMutabilityWarning(&response)
                    let body: OpenAPIRuntime.HTTPBody
                    switch value.body {
                    case let .json(value):
                        try converter.validateAcceptIfPresent(
                            "application/json",
                            in: request.headerFields
                        )
                        body = try converter.setResponseBodyAsJSON(
                            value,
                            headerFields: &response.headerFields,
                            contentType: "application/json; charset=utf-8"
                        )
                    }
                    return (response, body)
                case let .internalServerError(value):
                    suppressUnusedWarning(value)
                    var response = HTTPTypes.HTTPResponse(soar_statusCode: 500)
                    suppressMutabilityWarning(&response)
                    let body: OpenAPIRuntime.HTTPBody
                    switch value.body {
                    case let .plainText(value):
                        try converter.validateAcceptIfPresent(
                            "text/plain",
                            in: request.headerFields
                        )
                        body = try converter.setResponseBodyAsBinary(
                            value,
                            headerFields: &response.headerFields,
                            contentType: "text/plain"
                        )
                    }
                    return (response, body)
                case let .undocumented(statusCode, _):
                    return (.init(soar_statusCode: statusCode), nil)
                }
            }
        )
    }
    /// - Remark: HTTP `GET /pets/multipart-typed`.
    /// - Remark: Generated from `#/paths//pets/multipart-typed/get(multipartDownloadTyped)`.
    func multipartDownloadTyped(
        request: HTTPTypes.HTTPRequest,
        body: OpenAPIRuntime.HTTPBody?,
        metadata: OpenAPIRuntime.ServerRequestMetadata
    ) async throws -> (HTTPTypes.HTTPResponse, OpenAPIRuntime.HTTPBody?) {
        try await handle(
            request: request,
            requestBody: body,
            metadata: metadata,
            forOperation: Operations.MultipartDownloadTyped.id,
            using: {
                APIHandler.multipartDownloadTyped($0)
            },
            deserializer: { request, requestBody, metadata in
                let headers: Operations.MultipartDownloadTyped.Input.Headers = .init(accept: try converter.extractAcceptHeaderIfPresent(in: request.headerFields))
                return Operations.MultipartDownloadTyped.Input(headers: headers)
            },
            serializer: { output, request in
                switch output {
                case let .ok(value):
                    suppressUnusedWarning(value)
                    var response = HTTPTypes.HTTPResponse(soar_statusCode: 200)
                    suppressMutabilityWarning(&response)
                    let body: OpenAPIRuntime.HTTPBody
                    switch value.body {
                    case let .multipartForm(value):
                        try converter.validateAcceptIfPresent(
                            "multipart/form-data",
                            in: request.headerFields
                        )
                        body = try converter.setResponseBodyAsMultipart(
                            value,
                            headerFields: &response.headerFields,
                            contentType: "multipart/form-data",
                            allowsUnknownParts: true,
                            requiredExactlyOncePartNames: [
                                "log"
                            ],
                            requiredAtLeastOncePartNames: [],
                            atMostOncePartNames: [
                                "metadata"
                            ],
                            zeroOrMoreTimesPartNames: [
                                "keyword"
                            ],
                            encoding: { part in
                                switch part {
                                case let .log(wrapped):
                                    var headerFields: HTTPTypes.HTTPFields = .init()
                                    let value = wrapped.payload
                                    try converter.setHeaderFieldAsURI(
                                        in: &headerFields,
                                        name: "x-log-type",
                                        value: value.headers.xLogType
                                    )
                                    let body = try converter.setResponseBodyAsBinary(
                                        value.body,
                                        headerFields: &headerFields,
                                        contentType: "text/plain"
                                    )
                                    return .init(
                                        name: "log",
                                        filename: wrapped.filename,
                                        headerFields: headerFields,
                                        body: body
                                    )
                                case let .metadata(wrapped):
                                    var headerFields: HTTPTypes.HTTPFields = .init()
                                    let value = wrapped.payload
                                    let body = try converter.setResponseBodyAsJSON(
                                        value.body,
                                        headerFields: &headerFields,
                                        contentType: "application/json; charset=utf-8"
                                    )
                                    return .init(
                                        name: "metadata",
                                        filename: wrapped.filename,
                                        headerFields: headerFields,
                                        body: body
                                    )
                                case let .keyword(wrapped):
                                    var headerFields: HTTPTypes.HTTPFields = .init()
                                    let value = wrapped.payload
                                    let body = try converter.setResponseBodyAsBinary(
                                        value.body,
                                        headerFields: &headerFields,
                                        contentType: "text/plain"
                                    )
                                    return .init(
                                        name: "keyword",
                                        filename: wrapped.filename,
                                        headerFields: headerFields,
                                        body: body
                                    )
                                case let .undocumented(value):
                                    return value
                                }
                            }
                        )
                    }
                    return (response, body)
                case let .undocumented(statusCode, _):
                    return (.init(soar_statusCode: statusCode), nil)
                }
            }
        )
    }
    /// - Remark: HTTP `POST /pets/multipart-typed`.
    /// - Remark: Generated from `#/paths//pets/multipart-typed/post(multipartUploadTyped)`.
    func multipartUploadTyped(
        request: HTTPTypes.HTTPRequest,
        body: OpenAPIRuntime.HTTPBody?,
        metadata: OpenAPIRuntime.ServerRequestMetadata
    ) async throws -> (HTTPTypes.HTTPResponse, OpenAPIRuntime.HTTPBody?) {
        try await handle(
            request: request,
            requestBody: body,
            metadata: metadata,
            forOperation: Operations.MultipartUploadTyped.id,
            using: {
                APIHandler.multipartUploadTyped($0)
            },
            deserializer: { request, requestBody, metadata in
                let contentType = converter.extractContentTypeIfPresent(in: request.headerFields)
                let body: Components.RequestBodies.MultipartUploadTypedRequest
                let chosenContentType = try converter.bestContentType(
                    received: contentType,
                    options: [
                        "multipart/form-data"
                    ]
                )
                switch chosenContentType {
                case "multipart/form-data":
                    body = try converter.getRequiredRequestBodyAsMultipart(
                        OpenAPIRuntime.MultipartBody<Components.RequestBodies.MultipartUploadTypedRequest.MultipartFormPayload>.self,
                        from: requestBody,
                        transforming: { value in
                            .multipartForm(value)
                        },
                        boundary: contentType.requiredBoundary(),
                        allowsUnknownParts: true,
                        requiredExactlyOncePartNames: [
                            "log"
                        ],
                        requiredAtLeastOncePartNames: [],
                        atMostOncePartNames: [
                            "metadata"
                        ],
                        zeroOrMoreTimesPartNames: [
                            "keyword"
                        ],
                        decoding: { part in
                            let headerFields = part.headerFields
                            let (name, filename) = try converter.extractContentDispositionNameAndFilename(in: headerFields)
                            switch name {
                            case "log":
                                let headers: Components.RequestBodies.MultipartUploadTypedRequest.MultipartFormPayload.LogPayload.Headers = .init(xLogType: try converter.getOptionalHeaderFieldAsURI(
                                    in: headerFields,
                                    name: "x-log-type",
                                    as: Components.RequestBodies.MultipartUploadTypedRequest.MultipartFormPayload.LogPayload.Headers.XLogTypePayload.self
                                ))
                                try converter.verifyContentTypeIfPresent(
                                    in: headerFields,
                                    matches: "text/plain"
                                )
                                let body = try converter.getRequiredRequestBodyAsBinary(
                                    OpenAPIRuntime.HTTPBody.self,
                                    from: part.body,
                                    transforming: {
                                        $0
                                    }
                                )
                                return .log(.init(
                                    payload: .init(
                                        headers: headers,
                                        body: body
                                    ),
                                    filename: filename
                                ))
                            case "metadata":
                                try converter.verifyContentTypeIfPresent(
                                    in: headerFields,
                                    matches: "application/json"
                                )
                                let body = try await converter.getRequiredRequestBodyAsJSON(
                                    Components.RequestBodies.MultipartUploadTypedRequest.MultipartFormPayload.MetadataPayload.BodyPayload.self,
                                    from: part.body,
                                    transforming: {
                                        $0
                                    }
                                )
                                return .metadata(.init(
                                    payload: .init(body: body),
                                    filename: filename
                                ))
                            case "keyword":
                                try converter.verifyContentTypeIfPresent(
                                    in: headerFields,
                                    matches: "text/plain"
                                )
                                let body = try converter.getRequiredRequestBodyAsBinary(
                                    OpenAPIRuntime.HTTPBody.self,
                                    from: part.body,
                                    transforming: {
                                        $0
                                    }
                                )
                                return .keyword(.init(
                                    payload: .init(body: body),
                                    filename: filename
                                ))
                            default:
                                return .undocumented(part)
                            }
                        }
                    )
                default:
                    preconditionFailure("bestContentType chose an invalid content type.")
                }
                return Operations.MultipartUploadTyped.Input(body: body)
            },
            serializer: { output, request in
                switch output {
                case let .accepted(value):
                    suppressUnusedWarning(value)
                    var response = HTTPTypes.HTTPResponse(soar_statusCode: 202)
                    suppressMutabilityWarning(&response)
                    return (response, nil)
                case let .undocumented(statusCode, _):
                    return (.init(soar_statusCode: statusCode), nil)
                }
            }
        )
    }
}
